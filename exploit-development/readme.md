# exploit development

<!-- vim-markdown-toc GFM -->

* [theory](#theory)
  * [stack buffer overflows](#stack-buffer-overflows)
  * [return-oriented programming](#return-oriented-programming)
    * [return-to-libc](#return-to-libc)
    * [return-to-PLT](#return-to-plt)
* [countermeasures](#countermeasures)
  * [NX bit](#nx-bit)
  * [stack canaries](#stack-canaries)
  * [ASLR](#aslr)
  * [PIE](#pie)
  * [CFI](#cfi)
* [demos](#demos)
  * [the basics: check_pin](#the-basics-check_pin)
* [sources and references](#sources-and-references)

<!-- vim-markdown-toc -->

# theory

## stack buffer overflows

## return-oriented programming

### return-to-libc

TODO write about bypassing the NX bit by jumping to the C standard library

### return-to-PLT

TODO write about bypassing ASLR by jumping to the Procedure Linkage Table

# countermeasures

This section covers exploit mitigation techniques and how to disable them to make writing
the first exploit easier. This should only be done in a VM. This section focuses on Linux and gcc.

## NX bit

NX stands for No eXecute. This technology tries to remedy the issue that the Von Neumann architecture
uses the same memory for instructions and data which can result in arbitrary code execution.

> architecture-von-neumann-issue.jpg

<img src="../media/architecture-von-neumann-issue.jpg" width=400></img>

The NX bit allows marking specific segments as executable or not executable.
This prevents arbitrary code execution from the stack (by crashing the process).
It does not prevent return-to-libc attacks as the memory that contains
the C Standard library has to be executable.

---

To enable execution of instructions on the stack, gcc can be passed the `-z execstack` linker flag.

## stack canaries

Also known as stack cookies.

Provide stack smashing protection by pushing an additional value to the stack (on function calls).
On function return that value is checked and if it is incorrect it means the stack has been smashed.
In that case the program terminates with `SIGABRT` and warns about attempted stack smashing:

> stack-canary-triggered.jpg

<img src="../media/stack-canary-triggered.jpg"></img>

---

By default this is disabled in gcc, but some distributions patch gcc to enable it.
To disable stack canaries pass the `-fno-stack-protector` flag to gcc.

## ASLR

Address Space Layout Randomization.

---

`echo 0 | sudo tee /proc/sys/kernel/randomize_va_space` (until reboot)

## PIE

Position Independent Executables.

---

`-fno-pie`, `-no-pie`

## CFI

Control-Flow Integrity.

---

`-fcf-protection=none`

# demos

These are small independent demos that demonstrate a single technique each.

## the basics: check_pin

This program asks the user for a pin via stdin.<br>
There are two *expected* outcomes when running it:

1. if the pin is correct it exits with return value `0`
2. if the pin is wrong it exits with return value `1`

A possible usage scenario would be: `./check_pin && echo correct || echo wrong pin!`.

> check_pin.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INSTRUCTIONS "enter 3 digit pin:\n"

int check_pin() {
	char buffer[4]; // pin + null terminator.
	scanf("%s", buffer); // read pin.
	// compare pin char by char:
	while (strcmp(buffer, "042") != 0)
		return EXIT_FAILURE; // usually 1.
	return EXIT_SUCCESS; // usually 0.
}

int main(int argc, char** argv)
{
	printf("%s", INSTRUCTIONS);
	return check_pin();
}
```

* *note the following:*
  * we reserve 4 Byte for our `buffer` char array
    * 3 for the pin + 1 for the C-string `NULL` terminator that `scanf()` returns
  * **we never actually check how long the user input is**
    * we just take whatever the user provided to us and stuff it into our buffer

---

Let's compile it!

> compiling check_pin.c with gcc:
```sh
gcc check_pin.c -o check_pin -ggdb \
    -m32 -mpreferred-stack-boundary=2 \
    -z execstack -fno-stack-protector \
    -fno-pie -no-pie \
    -fcf-protection=none
```

* *note the following:*
  * `\`s are used to break up the command into multiple lines
  * `-o` specifies our executable name
  * `-ggdb` tells gdb to add debug symbols in its native format
  * `-m32` create 32-bit machine code
  * `-mpreferred-stack-boundary=2` align stack pointer to 4 Byte (2^n)
  * all the other flags disable various exploit mitigations<br>(see [countermeasures](#countermeasures) section)

---

Let's test it!

> check_pin with wrong pin:

```sh
./check_pin < <(echo 123) && echo correct || echo wrong!
```

> check_pin-wrong.jpg

<img src="../media/check_pin-wrong.jpg"></img>

> check_pin with correct pin:

```sh
./check_pin < <(echo 042) && echo correct || echo wrong!
```

> check_pin-correct.jpg

<img src="../media/check_pin-correct.jpg"></img>

Looks like our little program works just as we intended it to.

---

We know our program works fine if we follow the instructions.<br>
Let's see what happens when we stray from the happy path!

> check_pin with overlong input:

```sh
./check_pin <(echo aaaabbbbcccc) && echo correct || echo wrong!
```
> check_pin-segmentation-fault.jpg

<img src="../media/check_pin-segmentation-fault.jpg"></img>

Interesting.

Somewhere along the way we got a segmentation fault.

We still get a `wrong` because segmentation faults produce a return code of `139`
and that is not the same as `0`.<br>
In case you are wondering why `139`: unsuccessful termination produces an error
of `128` plus the signal code that was the reason for the termination. The code for a segmentation violation is `11`.
See: `man 7 signal`.

The signal segmentation violation/`SIGSEGV` means our program tried to access an invalid memory address.<br>
Let's give it another go from within gdb to find out why that happened.

> segfault investigation with gdb:

```sh
gdb check_pin

# (gdb)
break *main
run < <(echo aaaabbbbcccc)
# this starts our program and runs it until we hit main+0.

# from here on out we `step` over C source lines:
step # step over `{`, the function prologue.
step # step over the printf() call.

# we have stopped just before calling check_pin():
```

> check_pin-before-call.jpg

<img src="../media/check_pin-before-call.jpg"></img>

Now we step a single instruction (`stepi`) to execute `call <check_pin+0>`:

> check_pin-after-call.jpg

<img src="../media/check_pin-after-call.jpg"></img>

# sources and references

* [re4b] Yurichev, D. (2013). Reverse Engineering for Beginners. https://beginners.re
* [pracbin] Andriesse, D., & Francisco, S. (2018). PRACTICAL BINARY ANALYSIS Build Your Own Linux Tools for Binary Instrumentation, Analysis, and Disassembly (2nd ed.). No Starch Press.
