# exploit development

<!-- vim-markdown-toc GFM -->

* [theory](#theory)
  * [stack-based buffer overflows](#stack-based-buffer-overflows)
    * [historical contextext](#historical-contextext)
  * [return-oriented programming](#return-oriented-programming)
    * [return-to-libc](#return-to-libc)
    * [return-to-PLT](#return-to-plt)
* [countermeasures](#countermeasures)
  * [NX bit](#nx-bit)
  * [stack canaries](#stack-canaries)
  * [ASLR](#aslr)
  * [PIE](#pie)
  * [CFI](#cfi)
* [the basics](#the-basics)
  * [check_pin: source](#check_pin-source)
  * [check_pin: compilation](#check_pin-compilation)
  * [check_pin: testing](#check_pin-testing)
  * [check_pin: crash investigation](#check_pin-crash-investigation)
* [demos](#demos)
* [sources and references](#sources-and-references)

<!-- vim-markdown-toc -->

# theory

## stack-based buffer overflows

First popularized by the Morris worm and Elias Levy (aka. Aleph One) in his article for Phrack Magazine ([[smash]](#sources-and-references)),
buffer overflows are one of the most common weaknesses in software.

They happen when a process writes past the confines of a fixed-sized buffer that is stored on the stack ([[cwe121]](#sources-and-references)).
Depending on the specific memory layout this can allow for arbitrary code execution.

### historical contextext

The severity (and feasability) is impacted by a combination of low-level architectural- and high-level language-design decisions.

While stack-based buffer overflows are possible in Harvard architectures ([[hrvd]](#sources-and-references)),
the coexistance of data and instructions in the same memory in Von Neumann architectures makes them potentially more powerful.

Usually to improve performance, some languages (C/C++) don't enforce perimeters of buffers (arrays in this case) nor perform bounds checking.

## return-oriented programming

TODO write about ROP

### return-to-libc

TODO write about bypassing the NX bit by jumping to the C standard library

### return-to-PLT

TODO write about bypassing ASLR by jumping to the Procedure Linkage Table

# countermeasures

This section covers exploit mitigation techniques and how to disable them to make writing
the first exploit easier. This should only be done in a VM. This section focuses on Linux and gcc.

## NX bit

NX stands for No eXecute. This technology tries to remedy the issue that the Von Neumann architecture
uses the same memory for instructions and data which can result in arbitrary code execution.

> architecture-von-neumann-issue.jpg

<img src="../media/architecture-von-neumann-issue.jpg" width=400></img>

The NX bit allows marking specific segments as executable or not executable.
This prevents arbitrary code execution from the stack (by crashing the process).
It does not prevent return-to-libc attacks as the memory that contains
the C Standard library has to be executable.

---

To enable execution of instructions on the stack, gcc can be passed the `-z execstack` linker flag.

## stack canaries

Also known as stack cookies.

Provide stack smashing protection by pushing an additional value to the stack (on function calls).
On function return that value is checked and if it is incorrect it means the stack has been smashed.
In that case the program terminates with `SIGABRT` and warns about attempted stack smashing:

> stack-canary-triggered.jpg

<img src="../media/stack-canary-triggered.jpg"></img>

---

By default this is disabled in gcc, but some distributions patch gcc to enable it.
To disable stack canaries pass the `-fno-stack-protector` flag to gcc.

## ASLR

TODO write about Address Space Layout Randomization.

---

`echo 0 | sudo tee /proc/sys/kernel/randomize_va_space` (until reboot)

## PIE

TODO write about Position Independent Executables.

---

`-fno-pie`, `-no-pie`

## CFI

TODO write about Control-Flow Integrity.

---

`-fcf-protection=none`

# the basics

We'll use a small program (`check_pin`) with a subtle bug to look at how a stack buffer overflow can happen and what consequences might follow.

## check_pin: source

This program asks the user for a pin via stdin.<br>
There are two expected outcomes when running it:

1. if the pin is correct it exits with return value `0`
2. if the pin is wrong it exits with return value `1`

A possible usage scenario would be: `./check_pin && echo correct || echo wrong!`. Here's the source:

> check_pin.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INSTRUCTIONS "enter 3 digit pin:\n"

int check_pin() {
	char buffer[4]; // pin + null terminator.
	scanf("%s", buffer); // read pin.
	// compare pin char by char:
	while (strcmp(buffer, "042") != 0)
		return EXIT_FAILURE; // usually 1.
	return EXIT_SUCCESS; // usually 0.
}

int main(int argc, char** argv)
{
	printf("%s", INSTRUCTIONS);
	return check_pin();
}
```

* *note the following:*
  * we reserve 4 Bytes for our `buffer` char array
    * 3 for the pin + 1 for the C-string `NULL` terminator that `scanf()` outputs
  * **we never actually check how long the user input is**
    * we just take whatever the user provided to us and stuff it into our buffer

## check_pin: compilation

Let's compile it!

> compiling check_pin.c with gcc:
```sh
gcc check_pin.c -o check_pin -ggdb \
    -m32 -mpreferred-stack-boundary=2 \
    -z execstack -fno-stack-protector \
    -fno-pie -no-pie \
    -fcf-protection=none
```

* *note the following:*
  * `\`s are used to break up the command into multiple lines
  * `-o` specifies our executable name
  * `-ggdb` tells gdb to add debug symbols in its native format
  * `-m32` create 32-bit machine code
  * `-mpreferred-stack-boundary=2` align stack pointer to 4 Bytes (2^n)
  * all the other flags disable various exploit mitigations<br>(see [countermeasures](#countermeasures) section)

## check_pin: testing

Let's test it!

> check_pin with wrong pin:

```sh
./check_pin < <(echo 123) && echo correct || echo wrong!
```

> check_pin-wrong.jpg

<img src="../media/check_pin-wrong.jpg"></img>

> check_pin with correct pin:

```sh
./check_pin < <(echo 042) && echo correct || echo wrong!
```

> check_pin-correct.jpg

<img src="../media/check_pin-correct.jpg"></img>

Looks like our little program works just as we intended it to.

---

We know our program works fine if we follow the instructions.<br>
Let's see what happens when we stray from the happy path!

> check_pin with overlong input:

```sh
./check_pin <(echo aaaabbbbcccc) && echo correct || echo wrong!
```
> check_pin-segmentation-fault.jpg

<img src="../media/check_pin-segmentation-fault.jpg"></img>

Interesting.

Somewhere along the way we got a segmentation fault.

We still get a `wrong` because segmentation faults produce a return code of `139`
and that is not the same as `0`.<br>
In case you are wondering why `139`: unsuccessful termination produces an error
of `128` plus the signal code that was the reason for the termination. The code for a segmentation violation is `11`.
See: `man 7 signal`.

## check_pin: crash investigation

The signal segmentation violation/`SIGSEGV` means our program tried to access an invalid memory address.<br>
Let's give it another go from within gdb to find out why that happened.

> segfault investigation with gdb:

```sh
gdb check_pin

# (gdb)
break *main
run < <(echo aaaabbbbcccc)
# this starts our program and runs it until we hit main+0.
# we use input redirection so we don't have to enter our input
# to scanf() during our debugging session.

# from here on out we `step` over C source lines:
step # step over `{`, the function prologue.
step # step over the printf() call.

# we have stopped just before calling check_pin():
```

> check_pin-before-call.jpg

<img src="../media/check_pin-before-call.jpg"></img>

* *note the following:*
  * gdb gef shows us seven different sections that are labeled in the top right (see [gdb â†£](../gdb) for details)
  * (a.) shows the instruction pointer, it points at the address of the *upcoming instruction*
    * its value is `0x080491e1`, which is the `call 0x8049196` instruction; compare with (c.)
  * (b.) this line is the youngest entry on the stack, note the address `0xffffd438`
  * (c.) this is the machine instruction that will be executed next
  * aditionally we get the position in the original source as well (thanks to debug symbols)
    * for each line of C code there can be multiple assembly instructions

Now we step a single instruction (`stepi`) to execute `call <check_pin+0>`:

> check_pin-after-call.jpg

<img src="../media/check_pin-after-call.jpg"></img>

* *note the following:*
  * (a.) the instruction pointer has been updated, now it points to the first instruction in `check_pin`
  * (b.) the stack just grew by 4 Bytes (compare the address with the previously youngest item)
    * `call` instructions push the *return address* of the calling function onto the stack
    * **this is how we keep track of where execution should continue after a function ends**
    * at the end of `check_pin` this address is popped and the instruction pointer set to it
  * (c.) the next instruction is `push ebp`
    * this will backup the *base pointer* of the previous stack frame to the stack
    * this way it can be restored when we return
  * if you compare the previous `trace` section to this one you will see that we gained a line
    * this displays the backtrace, a list of function calls
    * `#0` is always the current one and the higher the number the older the call

Use `stepi 3` to step over the first three instructions of the `check_pin` function.<br>
This block is called the function prologue and its purpose is to set up the stack frame for `check_pin`.

The function prologue will:
* backup the base pointer to the stack,
* change the value of the base pointer to that of the stack pointer,
* and then grow the stack by 4 more Bytes to accomodate our `buffer`.

This will be our new state:

> check_pin-after-prologue.jpg

<img src="../media/check_pin-after-prologue.jpg"></img>

* *note the following:*
  * The three youngest items on the stack are:
    * (a.) 4 Bytes: the return address to `main`
    * (b.) 4 Bytes: the backup of the base pointer of `main`s stack frame
    * (c.) 4 Bytes: space for our `buffer` array

---

Let's create a drawing of our current stack layout.<br>
We'll add another 4 Bytes above the return address to symbolize that the stack continues on (upwards).

> check_pin-input-layout.jpg

<img src="../media/check_pin-input-layout.jpg"></img>

* *note the following:*
  * above our buffer is the backup of `main`s base pointer
  * above the backup of the base pointer is the return address to `main`

---

This works fine as long as we stick to the instructions of our program.
3 Bytes for the pin plus 1 spare Byte for the `NULL` terminator:

> check_pin-input-valid.jpg

<img src="../media/check_pin-input-valid.jpg"></img>

* *note the following:*
  * the stack grows down
  * our buffer array grows up
    * the reason is C's array indexing/pointer arithmetic

---

Here's the problem though: we provided an overlong input and the program never checked the length.<br>
`scanf()` does not care and mindlessly continues to write Bytes as if our buffer was longer.

> check_pin-input-overlong.jpg

<img src="../media/check_pin-input-overlong.jpg"></img>

* *note the following:*
  * `scanf()` has no concept of buffer length
    * it simply calculates the address for `buffer[n]`
    * the first `b` lands in `buffer[4]`, even though that's past the reserved space
  * Bytes 0-3 (`aaaa`) land in our buffer
  * Bytes 4-7 (`bbbb`) overwrite the backup of the base pointer
  * Bytes 8-11 (`cccc`) overwrite the return address
  * Byte 12 (`NULL`) overwrites whatever is above the return address

When `check_pin()` returns to `main()` the trashed base pointer is restored.<br>
**Crucially, in the next step the instruction pointer is trashed via the popped return address.**

The instruction pointer is set to `cccc` (hex `0x63 63 63 63`) and since we can't jump to that address we get a segfault.

---

If we let the rest of the program run out with `continue` we can see the state after the crash:

> check_pin-after-crash.jpg

<img src="../media/check_pin-after-crash.jpg"></img>

* *note the following:*
  * (a.) the base pointer was set to `bbbb`
  * (b.) the instruction pointer was set to `cccc`
  * (c.) we got a `SIGSEV` because `cccc` in hex is not an address we can access

We don't have much use for the base pointer, but control over the instruction pointer is fantastic:

**We can jump anywhere we please!**

# demos

These are small independent demos that demonstrate a single technique each.

TODO add shell code exploit demo

# sources and references

* [cwe121] CLASP. (2006). CWE-121: Stack-based Buffer Overflow. Mitre. https://cwe.mitre.org/data/definitions/121.html
* [hrvd] Watts, K., & Oman, P. (2009). Stack-based buffer overflows in Harvard class embedded systems. IFIP Advances in Information and Communication Technology, 311. https://doi.org/10.1007/978-3-642-04798-5_13
* [pracbin] Andriesse, D., & Francisco, S. (2018). PRACTICAL BINARY ANALYSIS Build Your Own Linux Tools for Binary Instrumentation, Analysis, and Disassembly (2nd ed.). No Starch Press.
* [re4b] Yurichev, D. (2013). Reverse Engineering for Beginners. https://beginners.re
* [smash] Alpeph One. (1996). Smashing The Stack For Fun And Profit. Phrack.
