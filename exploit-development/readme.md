# exploit development

<!-- vim-markdown-toc GFM -->

* [theory](#theory)
  * [stack buffer overflows](#stack-buffer-overflows)
  * [return-oriented programming](#return-oriented-programming)
    * [return-to-libc](#return-to-libc)
    * [return-to-PLT](#return-to-plt)
* [countermeasures](#countermeasures)
  * [NX bit](#nx-bit)
  * [stack canaries](#stack-canaries)
  * [ASLR](#aslr)
  * [PIE](#pie)
  * [CFI](#cfi)
* [the basics](#the-basics)
  * [check_pin: source](#check_pin-source)
  * [check_pin: compilation](#check_pin-compilation)
  * [check_pin: testing](#check_pin-testing)
  * [check_pin: crash investigation](#check_pin-crash-investigation)
* [demos](#demos)
* [sources and references](#sources-and-references)

<!-- vim-markdown-toc -->

# theory

## stack buffer overflows

## return-oriented programming

### return-to-libc

TODO write about bypassing the NX bit by jumping to the C standard library

### return-to-PLT

TODO write about bypassing ASLR by jumping to the Procedure Linkage Table

# countermeasures

This section covers exploit mitigation techniques and how to disable them to make writing
the first exploit easier. This should only be done in a VM. This section focuses on Linux and gcc.

## NX bit

NX stands for No eXecute. This technology tries to remedy the issue that the Von Neumann architecture
uses the same memory for instructions and data which can result in arbitrary code execution.

> architecture-von-neumann-issue.jpg

<img src="../media/architecture-von-neumann-issue.jpg" width=400></img>

The NX bit allows marking specific segments as executable or not executable.
This prevents arbitrary code execution from the stack (by crashing the process).
It does not prevent return-to-libc attacks as the memory that contains
the C Standard library has to be executable.

---

To enable execution of instructions on the stack, gcc can be passed the `-z execstack` linker flag.

## stack canaries

Also known as stack cookies.

Provide stack smashing protection by pushing an additional value to the stack (on function calls).
On function return that value is checked and if it is incorrect it means the stack has been smashed.
In that case the program terminates with `SIGABRT` and warns about attempted stack smashing:

> stack-canary-triggered.jpg

<img src="../media/stack-canary-triggered.jpg"></img>

---

By default this is disabled in gcc, but some distributions patch gcc to enable it.
To disable stack canaries pass the `-fno-stack-protector` flag to gcc.

## ASLR

Address Space Layout Randomization.

---

`echo 0 | sudo tee /proc/sys/kernel/randomize_va_space` (until reboot)

## PIE

Position Independent Executables.

---

`-fno-pie`, `-no-pie`

## CFI

Control-Flow Integrity.

---

`-fcf-protection=none`

# the basics

We'll use a small program (`check_pin`) with a subtle bug to look at how a stack buffer overflow can happen and what consequences might follow.

## check_pin: source

This program asks the user for a pin via stdin.<br>
There are two expected outcomes when running it:

1. if the pin is correct it exits with return value `0`
2. if the pin is wrong it exits with return value `1`

A possible usage scenario would be: `./check_pin && echo correct || echo wrong pin!`. Here's the source:

> check_pin.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INSTRUCTIONS "enter 3 digit pin:\n"

int check_pin() {
	char buffer[4]; // pin + null terminator.
	scanf("%s", buffer); // read pin.
	// compare pin char by char:
	while (strcmp(buffer, "042") != 0)
		return EXIT_FAILURE; // usually 1.
	return EXIT_SUCCESS; // usually 0.
}

int main(int argc, char** argv)
{
	printf("%s", INSTRUCTIONS);
	return check_pin();
}
```

* *note the following:*
  * we reserve 4 Bytes for our `buffer` char array
    * 3 for the pin + 1 for the C-string `NULL` terminator that `scanf()` outputs
  * **we never actually check how long the user input is**
    * we just take whatever the user provided to us and stuff it into our buffer

## check_pin: compilation

Let's compile it!

> compiling check_pin.c with gcc:
```sh
gcc check_pin.c -o check_pin -ggdb \
    -m32 -mpreferred-stack-boundary=2 \
    -z execstack -fno-stack-protector \
    -fno-pie -no-pie \
    -fcf-protection=none
```

* *note the following:*
  * `\`s are used to break up the command into multiple lines
  * `-o` specifies our executable name
  * `-ggdb` tells gdb to add debug symbols in its native format
  * `-m32` create 32-bit machine code
  * `-mpreferred-stack-boundary=2` align stack pointer to 4 Bytes (2^n)
  * all the other flags disable various exploit mitigations<br>(see [countermeasures](#countermeasures) section)

## check_pin: testing

Let's test it!

> check_pin with wrong pin:

```sh
./check_pin < <(echo 123) && echo correct || echo wrong!
```

> check_pin-wrong.jpg

<img src="../media/check_pin-wrong.jpg"></img>

> check_pin with correct pin:

```sh
./check_pin < <(echo 042) && echo correct || echo wrong!
```

> check_pin-correct.jpg

<img src="../media/check_pin-correct.jpg"></img>

Looks like our little program works just as we intended it to.

---

We know our program works fine if we follow the instructions.<br>
Let's see what happens when we stray from the happy path!

> check_pin with overlong input:

```sh
./check_pin <(echo aaaabbbbcccc) && echo correct || echo wrong!
```
> check_pin-segmentation-fault.jpg

<img src="../media/check_pin-segmentation-fault.jpg"></img>

Interesting.

Somewhere along the way we got a segmentation fault.

We still get a `wrong` because segmentation faults produce a return code of `139`
and that is not the same as `0`.<br>
In case you are wondering why `139`: unsuccessful termination produces an error
of `128` plus the signal code that was the reason for the termination. The code for a segmentation violation is `11`.
See: `man 7 signal`.

## check_pin: crash investigation

The signal segmentation violation/`SIGSEGV` means our program tried to access an invalid memory address.<br>
Let's give it another go from within gdb to find out why that happened.

> segfault investigation with gdb:

```sh
gdb check_pin

# (gdb)
break *main
run < <(echo aaaabbbbcccc)
# this starts our program and runs it until we hit main+0.

# from here on out we `step` over C source lines:
step # step over `{`, the function prologue.
step # step over the printf() call.

# we have stopped just before calling check_pin():
```

> check_pin-before-call.jpg

<img src="../media/check_pin-before-call.jpg"></img>

* *note the following:*
  * gdb gef shows us seven different sections that are labeled in the top right (see [gdb â†£](../gdb) for details)
  * (a.) shows the instruction pointer, it points at the address of the *upcoming instruction*
    * its value is `0x080491e1`, which is the `call 0x8049196` instruction; compare with (c.)
  * (b.) this line is the youngest entry on the stack, note the address `0xffffd438`
  * (c.) this is the machine instruction that will be executed next
  * aditionally we get the position in the original source as well (thanks to debug symbols)
    * for each line of C code there can be multiple assembly instructions

Now we step a single instruction (`stepi`) to execute `call <check_pin+0>`:

> check_pin-after-call.jpg

<img src="../media/check_pin-after-call.jpg"></img>

* *note the following:*
  * (a.) the instruction pointer has been updated, now it points to the first instruction in `check_pin`
  * (b.) the stack just grew by 4 Bytes (compare the address with the previously youngest item)
    * `call` instructions push the *return address* of the calling function onto the stack
    * **this is how we keep track of where execution should continue after a function ends**
    * at the end of `check_pin` this address is popped and the instruction pointer set to it
  * (c.) the next instruction is `push ebp`
    * this will backup the *base pointer* of the previous stack frame to the stack
    * this way it can be restored when we return
  * if you compare the previous `trace` section to this one you will see that we gained a line
    * this displays the backtrace, a list of function calls
    * `#0` is always the current one and the higher the number the older the call

Use `stepi 3` to step over the first three instructions of the `check_pin` function.<br>
This block is called the function prologue and its purpose is to set up the stack frame for `check_pin`.

The function prologue will:
* backup the base pointer to the stack,
* change the value of the base pointer to that of the stack pointer,
* and then grow the stack by 4 more Bytes to accomodate our `buffer`.

This will be our new state:

> check_pin-after-prologue.jpg

<img src="../media/check_pin-after-prologue.jpg"></img>

---

> check_pin-input-layout.jpg

<img src="../media/check_pin-input-layout.jpg"></img>

---

> check_pin-input-valid.jpg

<img src="../media/check_pin-input-valid.jpg"></img>

---

> check_pin-input-overlong.jpg

<img src="../media/check_pin-input-overlong.jpg"></img>

# demos

These are small independent demos that demonstrate a single technique each.

# sources and references

* [re4b] Yurichev, D. (2013). Reverse Engineering for Beginners. https://beginners.re
* [pracbin] Andriesse, D., & Francisco, S. (2018). PRACTICAL BINARY ANALYSIS Build Your Own Linux Tools for Binary Instrumentation, Analysis, and Disassembly (2nd ed.). No Starch Press.
